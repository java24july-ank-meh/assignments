/*Begin SQL workbook*/
/*2.1*/  
SELECT * FROM EMPLOYEE;

SELECT * 
FROM EMPLOYEE
WHERE LASTNAME= 'King';

SELECT *
FROM EMPLOYEE
WHERE FIRSTNAME = 'Andrew' AND
REPORTSTO IS NULL;

/*2.2*/

SELECT *
FROM ALBUM
ORDER BY TITLE DESC;

SELECT FIRSTNAME
FROM CUSTOMER 
ORDER BY CITY;

/**2.3*/
INSERT INTO GENRE VALUES (26, 'Horror');
INSERT INTO GENRE VALUES (27, 'Brick'); 
/*GENREID is defined as not null. must be provided in insert statement.
Obviously, GENREID, being the primary key, must be unique*/

INSERT INTO EMPLOYEE (EMPLOYEEID, LASTNAME, FIRSTNAME)
   VALUES(9, 'Hutchins', 'Beef');

INSERT INTO EMPLOYEE 
   VALUES (10, 'Collins', 'Shirley', 'CEO', 10, '09-MAY-72', '04-JAN-2014',
   '1021 Elden St', 'Herndon', 'VA', 'US', '27514', '+1(919) 454-7838', Null,
   'scollins@gmail.com');
   
INSERT INTO CUSTOMER (CUSTOMERID, FIRSTNAME, LASTNAME, EMAIL) 
   VALUES(60, 'Johnny', 'Kay', 'jkway@gmail.com');

INSERT INTO CUSTOMER (CUSTOMERID, FIRSTNAME, LASTNAME, SUPPORTREPID, 
   EMAIL, COMPANY) VALUES(61, 'Chris', 'Palmour', 5, 'chp@gmail.com', 'Revaure');
 
/*2.4*/  
UPDATE CUSTOMER SET FIRSTNAME = 'Robert', LASTNAME = 'Walter'
   WHERE FIRSTNAME = 'Aaron' AND LASTNAME = 'Mitchell';
   
UPDATE ARTIST SET NAME = 'CCR' WHERE NAME = 'Creedence Clearwater Revival';

/*2.5*/
SELECT * FROM INVOICE WHERE BILLINGADDRESS LIKE 'T%';

/*2.6*/
SELECT * FROM INVOICE WHERE TOTAL BETWEEN 15 AND 50;
SELECT * FROM EMPLOYEE WHERE HIREDATE BETWEEN '1-JUNE-03' AND '1-MARCH-04';

/*2.7*/
/*SELECT * FROM CUSTOMER WHERE FIRSTNAME = 'Robert' AND LASTNAME = 'Walter';

SELECT * FROM INVOICE WHERE CUSTOMERID = 
   (SELECT CUSTOMERID FROM CUSTOMER WHERE FIRSTNAME = 'Robert' AND 
   LASTNAME = 'Walter');
   
  DELETE FROM CUSTOMER WHERE FIRSTNAME = 'Robert' AND LASTNAME = 'Walter'; */

/*delete fk constraint and modify it to include cascade on delete*/
ALTER TABLE INVOICE 
DROP CONSTRAINT FK_INVOICECUSTOMERID;

ALTER TABLE INVOICE
ADD CONSTRAINT FK_CUSTOMERID
FOREIGN KEY (CUSTOMERID)
REFERENCES CUSTOMER
ON DELETE CASCADE;

ALTER TABLE INVOICELINE
DROP CONSTRAINT FK_INVOICELINEINVOICEID;

ALTER TABLE INVOICELINE
ADD CONSTRAINT FK_INVOICELINEINVOICELINEID
FOREIGN KEY (INVOICEID)
REFERENCES INVOICE
ON DELETE CASCADE;

DELETE FROM CUSTOMER WHERE FIRSTNAME = 'Robert' AND LASTNAME = 'Walter';

/*3.1*/
CREATE OR REPLACE FUNCTION PRINT_CURRENT_TIME RETURN NUMBER IS Z NUMBER;
BEGIN 
    DBMS_OUTPUT.PUT_LINE(CURRENT_TIMESTAMP);
    Z:=0;
    RETURN Z;
END;
/
/*Fetch a given tuple from mediatype, return the length of its name*/
CREATE OR REPLACE FUNCTION LENGTH_OF_MEDIATYPE(M_ID IN NUMBER) 
    RETURN NUMBER 
IS 
    LTH NUMBER;
    CURSOR C IS 
        SELECT LENGTH(NAME)
        FROM MEDIATYPE 
        WHERE MEDIATYPEID=M_ID;
BEGIN
    OPEN C;
    LOOP
        FETCH C INTO LTH;
        EXIT WHEN C%NOTFOUND;
    END LOOP;
    CLOSE C;
    RETURN LTH;
END;
/
/*Call PRINT_CURRENT_TIME*/
DECLARE Z NUMBER;
BEGIN
    Z:=PRINT_CURRENT_TIME(); 
    /*Apparently, the function must have at least (exactly?) one return value
    and you have to assign the result to a variable to properly call the 
     function*/
END;
/

/*Call LENGTH_OF_MEDIATYPE*/
DECLARE LTH NUMBER;
BEGIN 
    LTH:=LENGTH_OF_MEDIATYPE(2);
    DBMS_OUTPUT.PUT_LINE(LTH);
END;
/

/*3.2*/
/*Find average total from INVOICE table*/
CREATE OR REPLACE FUNCTION AVG_INVOICE_TOTAL RETURN NUMBER 
IS
    AV NUMBER;
BEGIN
    SELECT AVG(TOTAL) INTO AV FROM INVOICE;
    RETURN AV;
END;
/
/*Call AVG_INVOICE_TOTAL*/
DECLARE AV NUMBER;
BEGIN 
    AV:=AVG_INVOICE_TOTAL();
    DBMS_OUTPUT.PUT_LINE('Average invoice total: '||AV);
END;
/

/*Get most expensive track*/
CREATE OR REPLACE FUNCTION MOST_EXPENSIVE_TRACK RETURN TRACK.NAME%TYPE
IS
    TRACKNAME TRACK.NAME%TYPE;
BEGIN
    SELECT NAME INTO TRACKNAME
    FROM TRACK
    WHERE UNITPRICE = (SELECT MAX(UNITPRICE) FROM TRACK) AND ROWNUM=1;
    RETURN TRACKNAME;
END;
/

/*Call MOST_EXPENSIVE_TRACK*/
DECLARE TRACKNAME TRACK.NAME%TYPE;
BEGIN 
    TRACKNAME:=MOST_EXPENSIVE_TRACK();
    DBMS_OUTPUT.PUT_LINE(TRACKNAME);
END;
/

/*3.3*/
/*Get average unit prive from INVOICELINE table*/
CREATE OR REPLACE FUNCTION AVG_INVOICELINE_PRICE RETURN NUMBER
IS
    AV NUMBER;
BEGIN
    SELECT AVG(UNITPRICE) INTO AV FROM INVOICELINE;
    RETURN AV;
END;
/

/*Call AVG_INVOICELINE_PRICE*/
DECLARE AV NUMBER;
BEGIN
    AV:=AVG_INVOICELINE_PRICE();
    DBMS_OUTPUT.PUT_LINE(AV);
END;
/

/*3.4 Table Valued Function*/
/*Create object type to contain returned fields*/
CREATE OR REPLACE TYPE FULL_EMPLOYEE_NAME AS OBJECT(
    FNAME VARCHAR(20 BYTE),
    LNAME VARCHAR(20 BYTE)
);
/
/*Create object type to represent table of FULL_EMPLOYEE_NAMEs*/
CREATE OR REPLACE TYPE FULL_EMPLOYEE_NAME_TABLE AS TABLE OF FULL_EMPLOYEE_NAME;
/

CREATE OR REPLACE FUNCTION GET_YOUNGISH_EMPLOYEES
    RETURN FULL_EMPLOYEE_NAME_TABLE
IS
    EMPS FULL_EMPLOYEE_NAME_TABLE;
    CURSOR C IS
        SELECT FIRSTNAME, LASTNAME
        FROM EMPLOYEE
        WHERE BIRTHDATE > '31-DEC-68';
    FNAME VARCHAR2(20 BYTE);
    LNAME VARCHAR2(20 BYTE);
BEGIN
    EMPS:=FULL_EMPLOYEE_NAME_TABLE();
    OPEN C;
    LOOP
        FETCH C INTO FNAME, LNAME;
        EXIT WHEN C%NOTFOUND;
        EMPS.EXTEND;
        EMPS(EMPS.COUNT):=FULL_EMPLOYEE_NAME(FNAME,LNAME); 
    END LOOP;
    CLOSE C;
    RETURN EMPS;
END;
/

/*Call GET_YOUNGISH_EMPLOYEES*/
DECLARE EMPS FULL_EMPLOYEE_NAME_TABLE; 
BEGIN
    EMPS:=GET_YOUNGISH_EMPLOYEES();
    FOR I IN 1 .. EMPS.COUNT LOOP
        DBMS_OUTPUT.PUT_LINE(EMPS(I).FNAME||' '||EMPS(I).LNAME);
    END LOOP;
END;

/*4.1*/
/*Select first and last names of all employees*/
CREATE OR REPLACE PROCEDURE ALL_EMPLOYEES(S OUT SYS_REFCURSOR) AS
BEGIN
    OPEN S FOR 
        SELECT FIRSTNAME, LASTNAME FROM EMPLOYEE;
END;
/

/*Call ALL_EMPLOYEES*/
DECLARE 
    S SYS_REFCURSOR;
    FN EMPLOYEE.FIRSTNAME%TYPE;
    LN EMPLOYEE.LASTNAME%TYPE;
BEGIN
    ALL_EMPLOYEES(S);
    LOOP
        FETCH S INTO FN, LN;
        EXIT WHEN S%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE(FN||' '||LN);
    END LOOP;
    CLOSE S;
END;
/
    
/*4.2*/
CREATE OR REPLACE PROCEDURE CHANGE_TITLE(EID IN INTEGER, NEW_TITLE IN EMPLOYEE.TITLE%TYPE) AS
BEGIN
    UPDATE EMPLOYEE SET TITLE=NEW_TITLE WHERE EMPLOYEEID = EID;
    DBMS_OUTPUT.PUT_LINE('New title: '||NEW_TITLE);
    COMMIT;
    
    EXCEPTION WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE('FAILED');
    ROLLBACK;
END;
/

/*Call CHANGE_TITLE*/
BEGIN CHANGE_TITLE(9, 'IT Staff'); END;
/    

/*Get manager of an employee*/
CREATE OR REPLACE PROCEDURE 
    GET_MANAGER(EID IN INTEGER, S OUT SYS_REFCURSOR) 
AS
BEGIN
    OPEN S FOR 
    SELECT FIRSTNAME, LASTNAME 
    FROM EMPLOYEE
    WHERE EMPLOYEEID = (
        SELECT REPORTSTO 
        FROM EMPLOYEE
        WHERE EMPLOYEEID = EID
    );
END;
/ 

/*Call GET_MANAGER*/
DECLARE 
    S SYS_REFCURSOR;
    FIRSTNAME EMPLOYEE.FIRSTNAME%TYPE;
    LASTNAME EMPLOYEE.LASTNAME%TYPE;
BEGIN
    GET_MANAGER(2, S);
    FETCH S INTO FIRSTNAME, LASTNAME;
    DBMS_OUTPUT.PUT_LINE('Manager is: '||FIRSTNAME||' '||LASTNAME);
END;
/

/*4.3*/
/*Return name and company of a customer*/
CREATE OR REPLACE PROCEDURE CUSTOMER_INFO(CID IN CUSTOMER.CUSTOMERID%TYPE,
CFIRST OUT CUSTOMER.FIRSTNAME%TYPE, CLAST OUT CUSTOMER.LASTNAME%TYPE,
CCOMPANY OUT CUSTOMER.COMPANY%TYPE)
AS 
BEGIN
    SELECT FIRSTNAME, LASTNAME, COMPANY INTO CFIRST, CLAST, CCOMPANY
    FROM CUSTOMER
    WHERE CUSTOMERID = CID;
END;
/

/*Call CUSTOMER_INFO*/
DECLARE 
    CFIRST CUSTOMER.FIRSTNAME%TYPE;
    CLAST CUSTOMER.LASTNAME%TYPE;
    CCOMPANY CUSTOMER.COMPANY%TYPE;
BEGIN
    CUSTOMER_INFO(3, CFIRST, CLAST, CCOMPANY);
    DBMS_OUTPUT.PUT_LINE('Customer '||CFIRST||' '||CLAST||' from ' ||CCOMPANY);
END;
/

/*5.0*/
/*Delete INVOICE given INVOICEID*/
CREATE OR REPLACE PROCEDURE DELETE_INVOICE(IID IN INVOICE.INVOICEID%TYPE)
AS
BEGIN
    DELETE FROM INVOICE WHERE INVOICEID = IID;
    COMMIT;
END;
/

/*Call DELETE_INVOICE*/
BEGIN DELETE_INVOICE(321); END;

/*Insert new CUSTOMER record*/
CREATE OR REPLACE PROCEDURE NEW_CUSTOMER(CID IN CUSTOMER.CUSTOMERID%TYPE,
FN IN CUSTOMER.FIRSTNAME%TYPE, LN IN CUSTOMER.LASTNAME%TYPE, 
CO IN CUSTOMER.COMPANY%TYPE, ADDR IN CUSTOMER.ADDRESS%TYPE, 
CTY IN CUSTOMER.CITY%TYPE, ST IN CUSTOMER.STATE%TYPE, 
CNTRY IN CUSTOMER.COUNTRY%TYPE, PC IN CUSTOMER.POSTALCODE%TYPE,
PN IN CUSTOMER.PHONE%TYPE, FX IN CUSTOMER.FAX%TYPE, EMA IN CUSTOMER.EMAIL%TYPE,
SRI IN CUSTOMER.SUPPORTREPID%TYPE)
AS 
BEGIN
    INSERT INTO CUSTOMER VALUES(CID,FN,LN,CO,ADDR,CTY,ST,CNTRY,PC,PN,FX,EMA,SRI);
END;
/

/*Call NEW_CUSTOMER*/
BEGIN
    NEW_CUSTOMER(62,'Homer', 'Simpson', 'Springfield Power Plant', 
    '742 Evergreen TeSrrace','Springfield', '', 'USA', 77777, '(555)555-5555',
    '(555)555-5555', 'hsimpson@gmail.com', 11);
END;

/*6.1*/
CREATE SEQUENCE SQ_PK_EMPLOYEE
START WITH 1
INCREMENT BY 1;
/

/*Ignore sequence above. I was gonna try to use it to automatically insert
  new, unique employeeids, but obvi you can't do that after the new tuple has
  already been inserted. i'm a dummy.*/

CREATE OR REPLACE TRIGGER TR_INSERT_EMP
AFTER INSERT ON EMPLOYEE
FOR EACH ROW 
BEGIN
    dbms_output.put_line('new id: ' || :NEW.EMPLOYEEID);
END;
/

/*INSERT INTO EMPLOYEE (EMPLOYEEID, LASTNAME, FIRSTNAME) 
VALUES(11,'Kleiman', 'Jermey');

DELETE FROM EMPLOYEE WHERE EMPLOYEEID = 11; */

/*Insert trigger for album*/
CREATE OR REPLACE TRIGGER TR_INSERT_ALBUM
AFTER INSERT ON ALBUM 
FOR EACH ROW
BEGIN
    dbms_output.put_line('new title: ' || :NEW.TITLE);
END;
/
/*After delete trigger on customer table*/
CREATE OR REPLACE TRIGGER TR_DELETE_CUSTOMER
AFTER DELETE ON CUSTOMER
FOR EACH ROW
BEGIN
    dbms_output.put_line('deleted customer name: ' || :OLD.FIRSTNAME || ' ' || :OLD.LASTNAME);
END;

/*7.1*/
SELECT CUSTOMER.CUSTOMERID, INVOICEID
FROM CUSTOMER
INNER JOIN INVOICE ON INVOICE.CUSTOMERID = CUSTOMER.CUSTOMERID;

/*7.2*/
SELECT C.CUSTOMERID, C.FIRSTNAME, C.LASTNAME, I.INVOICEID, I.TOTAL
FROM CUSTOMER C
FULL OUTER JOIN INVOICE I ON C.CUSTOMERID = I.CUSTOMERID;
/*Is there any point in the ON clause in a full outer join?
Yes: The ON clause keeps you from getting the full cartesian product of the
two tables. You will get every entry in both tables where the specified
field matches, plus the rows in each table for which there was no match*/

/*Since this is a well-designed db, all invoices reference an existing 
customer entry (foreign key constraint). And apparently, all customers have
at least one invoice. Compare the inner join below w/ the full outer join 
above*/
SELECT C.CUSTOMERID, C.FIRSTNAME, C.LASTNAME, I.INVOICEID, I.TOTAL
FROM CUSTOMER C
INNER JOIN INVOICE I ON C.CUSTOMERID = I.CUSTOMERID;

/*7.3*/
SELECT AR.NAME, AB.TITLE
FROM ARTIST AR
RIGHT JOIN ALBUM AB ON AR.ARTISTID = AB.ARTISTID;

/*7.4*/
SELECT *
FROM ALBUM AB
CROSS JOIN ARTIST AR
ORDER BY AR.NAME;

/*7.5*/
SELECT *
FROM EMPLOYEE E1, EMPLOYEE E2
WHERE E1.REPORTSTO = E2.REPORTSTO;

/*7.6 really?*/
SELECT *
FROM ALBUM AB
INNER JOIN ARTIST AR ON AR.ARTISTID = AB.ARTISTID
INNER JOIN CUSTOMER C ON AR.ARTISTID < C.CUSTOMERID
INNER JOIN DEPARTMENT D ON AR.ARTISTID = D.D_ID
INNER JOIN EMPLOYEE E ON E.EMPLOYEEID = C.SUPPORTREPID;


