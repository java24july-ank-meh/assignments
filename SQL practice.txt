/*SELECT*/
SELECT * FROM EMPLOYEE;
SELECT * FROM EMPLOYEE WHERE LASTNAME = 'King';
SELECT * FROM EMPLOYEE WHERE LASTNAME = 'King' AND REPORTSTO IS NULL;
/*Order by*/
SELECT * FROM ALBUM 
ORDER BY DSC;
SELECT FIRSTNAME FROM CUSTOMER 
ORDER BY CITY ASC;
/*INSERT INTO*/
INSERT INTO GENRE VALUES (26, 'Electro Swing');
INSERT INTO GENRE VALUES (27, 'Thrash Punk');

INSERT INTO EMPLOYEE (EMPLOYEEID, LASTNAME, FIRSTNAME) VALUES (70, 'Robertson', 'Max');
INSERT INTO EMPLOYEE (EMPLOYEEID, LASTNAME, FIRSTNAME) VALUES (81, 'Daniels', 'Jack');

INSERT INTO CUSTOMER (CUSTOMERID, FIRSTNAME, LASTNAME, EMAIL) VALUES (59, 'Marjorie', 'Hass', mhass@mail.com);
INSERT INTO CUSTOMER (CUSTOMERID, FIRSTNAME, LASTNAME, EMAIL) VALUES (60, 'Aaron', 'Block', ablock@mail.com);

/*UPDATE*/
UPDATE CUSTOMER 
SET FIRSTNAME = 'Robert', LASTNAME = 'Walter'
WHERE FIRSTNAME = 'Aaron' AND LASTNAME = 'Mitchell';

UPDATE CUSTOMER 
SET ARTIST 
SET NAME = 'CCR'
WHERE NAME = 'Creedence Clearwater Rivival';

/*LIKE*/
SELECT * FROM INVOICE 
WHERE BILLINGADDRESS LIKE 'T%';

/*BETWEEN*/
SELECT * FROM INVOICE
WHERE TOTAL BETWEEN 15 AND 50;

SELECT * FROM EMPLOYEE 
WHERE HIREDATE BETWEEN '01-JUN-03' AND '01-MAR-04';

 
/*DELETE: in order to do these must alter table constraints by deleting foreign 
keys and remaking them through alter statements*/
ALTER TABLE INVOICE 
DROP CONSTRAINT FK_CUSTOMERID;
ALTER TABLE INVOICE 
ADD CONSTRAINT FK_CUSTOMERID 
FOREIGN KEY (CUSTOMERID) REFERENCES CUSTOMER(CUSTOMERID)
ON DELETE CASCADE;

ALTER TABLE INVOICELINE
DROP CONSTRAINT FK_INVOICELINEINVOICEID;
ALTER TABLE INVOICELINE
ADD CONSTRAINT FK_INVOICELINEINVOICEID
FOREIGN KEY (INVOICEID) REFERENECES INVOICE(INVOICEID)
ON DELETE CASCADE;

DELETE FROM CUSTOMER 
WHERE FIRSTNAME = 'Robert' AND LASTNAME = 'Walter'; 



/*Create functions*/
/*Return date*/
CREATE OR REPLACE FUNCTION GET_TIME
    RETURN DATE AS THIS_TIME DATE;
BEGIN
    SELECT SYSDATE
        INTO THIS_TIME
        FROM DUAL;
        RETURN THIS_TIME;
END;
/

BEGIN
    DBMS_OUTPUT.PUT_LINE(GET_TIME);
END;

/*Return length of media type*/
CREATE OR REPLACE FUNCTION MEDIA_LENGTH
	RETURN NUMBER AS MEDIALENGTH NUMBER;
BEGIN
	SELECT COUNT(*)
	INTO MEDIALENGTH
	FROM MEDIATYPE;
	RETURN MEDIALENGTH;
END;

BEGIN
    DBMS_OUTPUT.PUT_LINE(MEDIA_LENGTH);
END;

/*Return most expensive track*/
CREATE OR REPLACE FUNCTION MOST_EXPENSIVE
    RETURN VARCHAR AS MEDIANAME TRACK.NAME%TYPE;
BEGIN 
    SELECT TRACK.NAME INTO MEDIANAME
    FROM TRACK
    WHERE UNITPRICE = (SELECT MAX(TRACK.UNITPRICE) FROM TRACK)
    AND ROWNUM <2;
    RETURN MEDIANAME;
END;
/
BEGIN 
    DBMS_OUTPUT.PUT_LINE(MOST_EXPENSIVE);
END;
 
 
/*Return avg price*/
CREATE OR REPLACE FUNCTION I_AVERAGEPRICE
    RETURN NUMBER AS AVGPRICE INVOICELINE.UNITPRICE%TYPE;
BEGIN 
    SELECT AVG(UNITPRICE) INTO AVGPRICE
    FROM INVOICELINE;
    RETURN AVGPRICE;
END;
/

BEGIN 
    DBMS_OUTPUT.PUT_LINE(I_AVERAGEPRICE);
END;


/*PROCEDURES*/
/*1. create the procedure by mentioning what you're going to grab
2. declare your variables with what you grabbed from the first begin/end statements
3. use the variables to create your statements that either show or alter */
/*first and last names of employees*/
CREATE OR REPLACE PROCEDURE ENAMES (S OUT SYS_REFCURSOR) AS
/*have to access the index of the cursor to use to display information: they act as read only */
BEGIN
    OPEN S FOR SELECT FIRSTNAME, LASTNAME FROM EMPLOYEE;
    /*First begin and end statement tells you what all is going to happen; in this case 
    it's "SELECT"*/
END;
/
/*this next part is used for testing purposes
declaring variables as the types they stand-in for 
*/
DECLARE 
    S SYS_REFCURSOR; 
    FIRSTS EMPLOYEE.FIRSTNAME%TYPE;
    LASTS EMPLOYEE.LASTNAME%TYPE;
BEGIN
    ENAMES(S);
    /*in this case, using a loop in order to get out all names dependent on the cursor*/
    LOOP 
    FETCH S INTO FIRSTS, LASTS;
    EXIT WHEN S%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(FIRSTS||' '|| LASTS);
    END LOOP;
    CLOSE S;
    /*S acts as an input stream so you have to close it too after accessing with "FETCH"*/
END;

/*update personal info*/
CREATE OR REPLACE PROCEDURE EMPLOYEE_INFO (
    C_LAST IN VARCHAR2,
    C_FIRST IN VARCHAR2,
    C_TITLE IN VARCHAR2,
    C_ADDRESS IN VARCHAR2,
    C_CITY IN VARCHAR2,
    C_PHONE IN VARCHAR2,
    C_ID IN NUMBER
)
IS
BEGIN     /*In this case, first begin/end statement is update/set*/
    UPDATE EMPLOYEE SET LASTNAME = C_LAST, 
                        FIRSTNAME = C_FIRST,
                        TITLE = C_TITLE,
                        ADDRESS = C_ADDRESS,
                        CITY = C_CITY,
                        PHONE = C_PHONE
    WHERE EMPLOYEEID = C_ID;
END;

DECLARE /*declaring out of being SUPER safe, but honestly this isn't necessary*/
    LASTS  EMPLOYEE.LASTNAME%TYPE := 'Heap';
    FIRSTS EMPLOYEE.FIRSTNAME%TYPE := 'Immogen';
    E_TITLE EMPLOYEE.TITLE%TYPE := 'IT Mangager';
    E_ADDRESS EMPLOYEE.ADDRESS%TYPE := '8293 Cyborg Lane';
    E_CITY EMPLOYEE.CITY%TYPE := 'London';
    E_PHONE EMPLOYEE.PHONE%TYPE := '+2 (435) 748-9873';
    E_ID EMPLOYEE.EMPLOYEEID%TYPE := 8;
BEGIN
    EMPLOYEE_INFO(LASTS, FIRSTS, E_TITLE, E_ADDRESS, E_CITY, E_PHONE, E_ID);
END;
    
CREATE OR REPLACE PROCEDURE CUSTOMERCOMP (
    S OUT SYS_REFCURSOR,
    CUSID IN NUMBER
)
IS 
BEGIN 
    OPEN S FOR
    SELECT FIRSTNAME,LASTNAME, COMPANY FROM CUSTOMER
    WHERE CUSTOMERID = CUSID;
END;
DECLARE 
        S SYS_REFCURSOR;
        CUSNAME CUSTOMER.FIRSTNAME%TYPE;
        CUSLAST CUSTOMER.LASTNAME%TYPE;
        COMPNAME CUSTOMER.COMPANY%TYPE;
BEGIN
    CUSTOMERCOMP(S, 4);
    FETCH S INTO CUSNAME, CUSLAST, COMPNAME;
    
    DBMS_OUTPUT.PUT_LINE(CUSNAME|| ' ' || CUSLAST||' '||COMPNAME);
    CLOSE S;
END;


/*Transactions: running two statements at the same time, that MUST run at the same time or data
gets lost*/

/*Cascade needs already performed in 2.0*/
SET TRANSACTION NAME 'DELETEINVOICE';
DELETE FROM INVOICE WHERE INVOICE.INVOICEID = '8';
DELETE FROM INVOICE WHERE INVOICEID = '23';

COMMIT;

CREATE OR REPLACE PROCEDURE NEW_CUS_RECORD(
    CUSID IN NUMBER,
    CUSNAME IN VARCHAR2,
    CUSLAST IN VARCHAR2,
    CUSMAIN IN VARCHAR2
)
IS
BEGIN
    INSERT INTO CUSTOMER (CUSTOMERID, FIRSTNAME, LASTNAME, EMAIL)
    VALUES(CUSID, CUSNAME, CUSLAST, CUSMAIN);
    COMMIT;
END;


/*Triggers: components that work by holding until a certain action has been taken*/
CREATE OR REPLACE TRIGGER NEW_EMPLOYEE
AFTER INSERT ON EMLOYEE
FOR EACH ROW

BEGIN 
    DBMS.OUTPUT_PUTLINE('new emp created ');
END;

CREATE OR REPLACE TRIGGER NEW_ALBUM
AFTER INSERT ON ALBUM
FOR EACH ROW 

BEGIN 
    DBMS.OUTPUT_PUTLINE('new album made');
END;

CREATE OR REPLACE TRIGGER CUSTOMER_OUT
AFTER DELETE ON CUSTOMER
FOR EACH ROW 

BEGIN 
    DBMS.OUTPUT_PUTLINE('customer is gone');
END;

/*Joins: joining like columns in tables*/
/*INNER JOIN: works with the foreign key in invoice*/
SELECT CUSTOMER.FIRSTNAME, INVOICE.INVOICEID FROM CUSTOMER INNER JOIN INVOICE ON CUSTOMER.CUSTOMERID = INVOICE.CUSTOMERID;

/*Outer join*/
SELECT CUSTOMER.FIRSTNAME, CUSTOMER.LASTNAME, INVOICE.INVOICEID, INVOICE.TOTAL FROM CUSTOMER FULL OUTER JOIN INVOICE ON CUSTOMER.CUSTOMERID = INVOICE.CUSTOMERID; 
/*will return everything based on invoiceId ordering*/
/*Right join*/
SELECT ARTIST.NAME, ALBUM.TITLE FROM ARTIST RIGHT JOIN ALBUM ON ARTIST.ARTISTID = ALBUM.ARTISTID;

/*Cross join*/
SELECT ARTIST.NAME FROM ARTIST CROSS JOIN ALBUM ORDER BY ALBUM.ALBUMID ASC;

/*Self join*/
SELECT a.REPORTSTO, b.FIRSTNAME
FROM EMPLOYEE a, EMPLOYEE b
WHERE a.REPORTSTO < b.REPORTSTO;

/*Complicated Inner Join*/
SELECT ALBUM.TITLE, ARTIST.NAME, CUSTOMER.FIRSTNAME, EMPLOYEE.FIRSTNAME, INVOICE.TOTAL, INVOICELINE.UNITPRICE,
MEDIATYPE.NAME, PLAYLIST.NAME, PLAYLISTTRACK.TRACKID, TRACK.NAME 
FROM CUSTOMER INNER JOIN EMPLOYEE ON CUSTOMER.SUPPORTREPID = EMPLOYEE.EMPLOYEEID 
INNER JOIN INVOICE ON CUSTOMER.CUSTOMERID = INVOICE.CUSTOMERID
INNER JOIN INVOICELINE ON INVOICE.INVOICEID = INVOICELINE.INVOICEID
INNER JOIN TRACK ON INVOICELINE.TRACKID = TRACK.TRACKID
INNER JOIN PLAYLISTTRACK ON TRACK.TRACKID = PLAYLISTTRACK.TRACKID
INNER JOIN PLAYLIST ON PLAYLISTTRACK.PLAYLISTID = PLAYLIST.PLAYLISTID
INNER JOIN MEDIATYPE ON TRACK.MEDIATYPEID = MEDIATYPE.MEDIATYPEID
INNER JOIN ALBUM ON TRACK.ALBUMID = ALBUM.ALBUMID
INNER JOIN ARTIST ON ALBUM.ARTISTID = ARTIST.ARTISTID;







